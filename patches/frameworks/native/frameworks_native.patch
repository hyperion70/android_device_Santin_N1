From 7355d66e240454ab8266ddda5ea96a34a5162cbb Mon Sep 17 00:00:00 2001
From: hyperion70 <bmaximov71@gmail.com>
Date: Tue, 1 Jan 2019 13:51:14 +0300
Subject: [PATCH] frameworks_native

Change-Id: Ia8477da7447f42b5b6d628ebadf4c6fe2f4ad71c
---
 include/gui/BufferQueueCore.h        |   4 --
 include/gui/IProducerListener.h      |   3 -
 include/media/openmax/OMX_IVCommon.h |  10 +++
 include/ui/Fence.h                   |  29 ++------
 include/ui/mediatek/GuiExtMonitor.h  | 133 +++++++++++++++++++++++++++++++++++
 include/ui/mediatek/IDumpTunnel.h    |  49 +++++++++++++
 include/ui/mediatek/RefBaseDump.h    |  34 +++++++++
 libs/gui/BufferQueueCore.cpp         |   1 -
 libs/gui/BufferQueueProducer.cpp     |   8 +--
 libs/gui/ConsumerBase.cpp            |  18 +----
 libs/gui/GLConsumer.cpp              |  12 ++--
 libs/gui/IProducerListener.cpp       |  26 -------
 libs/gui/SurfaceControl.cpp          |  16 +++++
 libs/ui/Android.mk                   |  17 ++++-
 libs/ui/Fence.cpp                    |  18 +++--
 libs/ui/GraphicBuffer.cpp            |  27 +++++++
 libs/ui/mediatek/Fence.cpp           |  58 +++++++++++++++
 libs/ui/mediatek/IDumpTunnel.cpp     | 116 ++++++++++++++++++++++++++++++
 libs/ui/mediatek/RefBaseDump.cpp     |  70 ++++++++++++++++++
 opengl/include/EGL/eglext.h          |   6 ++
 opengl/libs/EGL/Loader.cpp           |  85 ++--------------------
 opengl/libs/EGL/Loader.h             |   4 --
 opengl/libs/EGL/eglApi.cpp           |  70 ++++++++++++++++++
 opengl/libs/EGL/egl_entries.in       |   3 +
 vulkan/libvulkan/driver.cpp          |  72 ++-----------------
 25 files changed, 640 insertions(+), 249 deletions(-)
 create mode 100644 include/ui/mediatek/GuiExtMonitor.h
 create mode 100644 include/ui/mediatek/IDumpTunnel.h
 create mode 100644 include/ui/mediatek/RefBaseDump.h
 create mode 100644 libs/ui/mediatek/Fence.cpp
 create mode 100644 libs/ui/mediatek/IDumpTunnel.cpp
 create mode 100644 libs/ui/mediatek/RefBaseDump.cpp

diff --git a/include/gui/BufferQueueCore.h b/include/gui/BufferQueueCore.h
index 4e54ddb..14b7e04 100644
--- a/include/gui/BufferQueueCore.h
+++ b/include/gui/BufferQueueCore.h
@@ -185,10 +185,6 @@ private:
     // PID of the process which last successfully called connect(...)
     pid_t mConnectedPid;
 
-    // mLinkedToDeath is used to set a binder death notification on
-    // the producer.
-    sp<IProducerListener> mLinkedToDeath;
-
     // mConnectedProducerListener is used to handle the onBufferReleased
     // notification.
     sp<IProducerListener> mConnectedProducerListener;
diff --git a/include/gui/IProducerListener.h b/include/gui/IProducerListener.h
index b7826c6..3848a6c 100644
--- a/include/gui/IProducerListener.h
+++ b/include/gui/IProducerListener.h
@@ -41,7 +41,6 @@ public:
     // This is called without any lock held and can be called concurrently by
     // multiple threads.
     virtual void onBufferReleased() = 0; // Asynchronous
-    virtual bool needsReleaseNotify() = 0;
 };
 
 class IProducerListener : public ProducerListener, public IInterface
@@ -55,14 +54,12 @@ class BnProducerListener : public BnInterface<IProducerListener>
 public:
     virtual status_t onTransact(uint32_t code, const Parcel& data,
             Parcel* reply, uint32_t flags = 0);
-    virtual bool needsReleaseNotify();
 };
 
 class DummyProducerListener : public BnProducerListener
 {
 public:
     virtual void onBufferReleased() {}
-    virtual bool needsReleaseNotify() { return false; }
 };
 
 } // namespace android
diff --git a/include/media/openmax/OMX_IVCommon.h b/include/media/openmax/OMX_IVCommon.h
index f9b6f4b..607cfd0 100644
--- a/include/media/openmax/OMX_IVCommon.h
+++ b/include/media/openmax/OMX_IVCommon.h
@@ -165,6 +165,16 @@ typedef enum OMX_COLOR_FORMATTYPE {
      *  format for it. */
     OMX_COLOR_FormatYUV420Flexible = 0x7F420888,
 
+    OMX_COLOR_FormatVendorMTKYUV = 0x7F000001,
+    OMX_COLOR_FormatVendorMTKYUV_FCM = 0x7F000002,
+    OMX_COLOR_FormatVendorMTKYUV_UFO = 0x7F000003,
+    OMX_COLOR_FormatVendorMTKYUV_10BIT_H = 0x7F000004,
+    OMX_COLOR_FormatVendorMTKYUV_10BIT_V = 0x7F000005,
+    OMX_COLOR_FormatVendorMTKYUV_UFO_10BIT_H = 0x7F000006,
+    OMX_COLOR_FormatVendorMTKYUV_UFO_10BIT_V = 0x7F000007,
+    OMX_MTK_COLOR_FormatYV12 = 0x7F000200,
+    OMX_MTK_COLOR_FormatBitStream = 0x7F000300,
+
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index 48a7aa3..a3eb995 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -27,8 +27,6 @@
 #include <utils/String8.h>
 #include <utils/Timers.h>
 
-#include <experimental/optional>
-
 struct ANativeWindowBuffer;
 
 namespace android {
@@ -81,8 +79,6 @@ public:
     // becomes signaled when both f1 and f2 are signaled (even if f1 or f2 is
     // destroyed before it becomes signaled).  The name argument specifies the
     // human-readable name to associated with the new Fence object.
-    static sp<Fence> merge(const char* name, const sp<Fence>& f1,
-            const sp<Fence>& f2);
 
     static sp<Fence> merge(const String8& name, const sp<Fence>& f1,
             const sp<Fence>& f2);
@@ -98,27 +94,6 @@ public:
     // occurs then -1 is returned.
     nsecs_t getSignalTime() const;
 
-#if __cplusplus > 201103L
-    // hasSignaled returns whether the fence has signaled yet. Prefer this to
-    // getSignalTime() or wait() if all you care about is whether the fence has
-    // signaled. Returns an optional bool, which will have a value if there was
-    // no error.
-    inline std::experimental::optional<bool> hasSignaled() {
-        // The sync_wait call underlying wait() has been measured to be
-        // significantly faster than the sync_fence_info call underlying
-        // getSignalTime(), which might otherwise appear to be the more obvious
-        // way to check whether a fence has signaled.
-        switch (wait(0)) {
-            case NO_ERROR:
-                return true;
-            case -ETIME:
-                return false;
-            default:
-                return {};
-        }
-    }
-#endif
-
     // Flattenable interface
     size_t getFlattenedSize() const;
     size_t getFdCount() const;
@@ -136,6 +111,10 @@ private:
     const Fence& operator = (const Fence& rhs) const;
 
     int mFenceFd;
+
+private:
+    void dump(int fd);
+
 };
 
 }; // namespace android
diff --git a/include/ui/mediatek/GuiExtMonitor.h b/include/ui/mediatek/GuiExtMonitor.h
new file mode 100644
index 0000000..614d1c4
--- /dev/null
+++ b/include/ui/mediatek/GuiExtMonitor.h
@@ -0,0 +1,133 @@
+#ifndef __GUIEXT_MONITOR_H__
+#define __GUIEXT_MONITOR_H__
+
+
+#include <utils/String8.h>
+#include <utils/Singleton.h>
+#include <utils/KeyedVector.h>
+
+#include <ui/mediatek/IDumpTunnel.h>
+
+
+namespace android {
+
+template <typename TYPE, typename ITEM>
+class GuiExtMonitor : public Singleton<TYPE>
+{
+public:
+    GuiExtMonitor();
+    virtual ~GuiExtMonitor();
+
+    virtual status_t monitor(ITEM item);
+    virtual status_t unmonitor(ITEM item);
+
+    virtual status_t dump(String8& result, const char* prefix);
+
+protected:
+    status_t getProcessName();
+    virtual String8 getKeyName() const;
+
+protected:
+    bool mIsRegistered;
+    String8 mProcessName;
+    mutable Mutex mLock;
+    sp<BnDumpTunnel> mDumpTunnel;
+    KeyedVector<ITEM, int> mItemList;
+};
+
+
+//--------------------------------------------------------------------------------------------------
+
+template <typename TYPE, typename ITEM>
+GuiExtMonitor<TYPE, ITEM>::GuiExtMonitor()
+    : mIsRegistered(false) {
+    getProcessName();
+}
+
+
+template <typename TYPE, typename ITEM>
+GuiExtMonitor<TYPE, ITEM>::~GuiExtMonitor() {
+    Mutex::Autolock _l(mLock);
+
+    if (mIsRegistered) {
+        DumpTunnelHelper::getInstance().unregDump(getKeyName());
+        mIsRegistered = false;
+    }
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::monitor(ITEM item) {
+    Mutex::Autolock _l(mLock);
+
+    mItemList.add(item, 0);
+    if (!mIsRegistered)
+    {
+
+        class MonitorTunnel : public BnDumpTunnel {
+        public:
+            MonitorTunnel(GuiExtMonitor<TYPE, ITEM>* pMonitor)
+                : mMonitor(pMonitor) {}
+            virtual ~MonitorTunnel() {}
+
+            // IDumpTunnel interface
+            virtual status_t kickDump(String8& result, const char* prefix) {
+                return mMonitor->dump(result, prefix);
+            }
+
+        private:
+            GuiExtMonitor<TYPE, ITEM>* mMonitor;
+        };
+
+        mDumpTunnel = new MonitorTunnel(this);
+        if (DumpTunnelHelper::getInstance().regDump(mDumpTunnel, getKeyName())) {
+            mIsRegistered = true;
+        }
+    }
+    return NO_ERROR;
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::unmonitor(ITEM item) {
+    Mutex::Autolock _l(mLock);
+
+    mItemList.removeItem(item);
+    return NO_ERROR;
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::dump(String8& /*result*/, const char* /*prefix*/) {
+    return NO_ERROR;
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::getProcessName() {
+    int pid = getpid();
+    FILE *fp = fopen(String8::format("/proc/%d/cmdline", pid), "r");
+    if (NULL != fp) {
+        const size_t size = 64;
+        char proc_name[size];
+        fgets(proc_name, size, fp);
+        fclose(fp);
+        mProcessName = proc_name;
+    } else {
+        mProcessName = "unknownProcess";
+    }
+    return NO_ERROR;
+}
+
+
+#define IMPLEMENT_META_GUIEXTMONITOR(TYPE, ITEM, NAME)                                  \
+    ANDROID_SINGLETON_STATIC_INSTANCE(TYPE);                                            \
+    template <>                                                                         \
+    String8 GuiExtMonitor<TYPE, ITEM>::getKeyName() const {                             \
+        return String8::format("%s-[%d:%s]", NAME, getpid(), mProcessName.string());    \
+    }
+
+
+}; // namespace android
+
+#endif
\ No newline at end of file
diff --git a/include/ui/mediatek/IDumpTunnel.h b/include/ui/mediatek/IDumpTunnel.h
new file mode 100644
index 0000000..8f9b663
--- /dev/null
+++ b/include/ui/mediatek/IDumpTunnel.h
@@ -0,0 +1,49 @@
+#ifndef ANDROID_GUI_IDUMPTUNNEL_H
+#define ANDROID_GUI_IDUMPTUNNEL_H
+
+#include <binder/IInterface.h>
+#include <utils/Singleton.h>
+
+namespace android
+{
+
+class IDumpTunnel : public IInterface {
+protected:
+    enum {
+        DUMPTUNNEL_DUMP = IBinder::FIRST_CALL_TRANSACTION
+    };
+
+public:
+    DECLARE_META_INTERFACE(DumpTunnel);
+
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/) = 0;
+};
+
+class BnDumpTunnel : public BnInterface<IDumpTunnel>
+{
+    virtual status_t onTransact(uint32_t code,
+                                const Parcel& data,
+                                Parcel* reply,
+                                uint32_t flags = 0);
+};
+
+// helper class for libgui_ext dynamic linking
+class DumpTunnelHelper : public Singleton<DumpTunnelHelper> {
+    void* mSoHandle;
+    bool (*mRegDumpPtr)(const sp<IDumpTunnel>&, const String8&);
+    bool (*mUnregDumpPtr)(const String8&);
+
+public:
+    DumpTunnelHelper();
+    virtual ~DumpTunnelHelper();
+
+    // register tunnel into guiext-server with a given key name
+    // and need to unregister it back
+    // in general usage, need to use identical key name for reg/unreg pair
+    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
+    bool unregDump(const String8& key);
+};
+
+
+};
+#endif
diff --git a/include/ui/mediatek/RefBaseDump.h b/include/ui/mediatek/RefBaseDump.h
new file mode 100644
index 0000000..1ac8218
--- /dev/null
+++ b/include/ui/mediatek/RefBaseDump.h
@@ -0,0 +1,34 @@
+#ifndef ANDROID_REFBASE_DUMP_H__
+#define ANDROID_REFBASE_DUMP_H__
+
+#include <utils/String8.h>
+#include <ui/mediatek/GuiExtMonitor.h>
+
+namespace android {
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+class RefBaseMonitor : public GuiExtMonitor<RefBaseMonitor, RefBase*> {
+public:
+    RefBaseMonitor();
+    ~RefBaseMonitor() {}
+
+    // add refbase to the monitored list
+    status_t monitor(RefBase* pRb);
+
+    // dump all elements in the monitored list and call printRefs if mIsTracking equals 1
+    status_t dump(String8& result, const char* prefix);
+
+protected:
+    // build the key name to register in GuiExt Service
+    String8 getKeyName() const;
+
+private:
+    // if trackMe needed
+    bool mIsTracking;
+};
+
+
+}; // namespace android
+#endif
diff --git a/libs/gui/BufferQueueCore.cpp b/libs/gui/BufferQueueCore.cpp
index d610971..b61e851 100644
--- a/libs/gui/BufferQueueCore.cpp
+++ b/libs/gui/BufferQueueCore.cpp
@@ -59,7 +59,6 @@ BufferQueueCore::BufferQueueCore(const sp<IGraphicBufferAlloc>& allocator) :
     mConsumerListener(),
     mConsumerUsageBits(0),
     mConnectedApi(NO_CONNECTED_API),
-    mLinkedToDeath(),
     mConnectedProducerListener(),
     mSlots(),
     mQueue(),
diff --git a/libs/gui/BufferQueueProducer.cpp b/libs/gui/BufferQueueProducer.cpp
index ff85eb5..196cad5 100644
--- a/libs/gui/BufferQueueProducer.cpp
+++ b/libs/gui/BufferQueueProducer.cpp
@@ -1131,11 +1131,8 @@ status_t BufferQueueProducer::connect(const sp<IProducerListener>& listener,
                         BQ_LOGE("connect: linkToDeath failed: %s (%d)",
                                 strerror(-status), status);
                     }
-                    mCore->mLinkedToDeath = listener;
                 }
-                if (listener->needsReleaseNotify()) {
                     mCore->mConnectedProducerListener = listener;
-                }
             }
             break;
         default:
@@ -1198,9 +1195,9 @@ status_t BufferQueueProducer::disconnect(int api, DisconnectMode mode) {
                     mCore->freeAllBuffersLocked();
 
                     // Remove our death notification callback if we have one
-                    if (mCore->mLinkedToDeath != NULL) {
+                    if (mCore->mConnectedProducerListener != NULL) {
                         sp<IBinder> token =
-                                IInterface::asBinder(mCore->mLinkedToDeath);
+                                IInterface::asBinder(mCore->mConnectedProducerListener);
                         // This can fail if we're here because of the death
                         // notification, but we just ignore it
                         token->unlinkToDeath(
@@ -1208,7 +1205,6 @@ status_t BufferQueueProducer::disconnect(int api, DisconnectMode mode) {
                     }
                     mCore->mSharedBufferSlot =
                             BufferQueueCore::INVALID_BUFFER_SLOT;
-                    mCore->mLinkedToDeath = NULL;
                     mCore->mConnectedProducerListener = NULL;
                     mCore->mConnectedApi = BufferQueueCore::NO_CONNECTED_API;
                     mCore->mConnectedPid = -1;
diff --git a/libs/gui/ConsumerBase.cpp b/libs/gui/ConsumerBase.cpp
index 3cf3078..ea6396b 100644
--- a/libs/gui/ConsumerBase.cpp
+++ b/libs/gui/ConsumerBase.cpp
@@ -314,23 +314,11 @@ status_t ConsumerBase::addReleaseFenceLocked(int slot,
 
     if (!mSlots[slot].mFence.get()) {
         mSlots[slot].mFence = fence;
-        return OK;
-    }
-
-    auto signaled = mSlots[slot].mFence->hasSignaled();
-
-    if (!signaled) {
-        CB_LOGE("fence has invalid state");
-        return BAD_VALUE;
-    }
-
-    if (*signaled) {
-        mSlots[slot].mFence = fence;
     } else {
-        char fenceName[32] = {};
-        snprintf(fenceName, 32, "%.28s:%d", mName.string(), slot);
         sp<Fence> mergedFence = Fence::merge(
-                fenceName, mSlots[slot].mFence, fence);
+                String8::format("%.28s:%d", mName.string(), slot),
+                mSlots[slot].mFence, fence);
+
         if (!mergedFence.get()) {
             CB_LOGE("failed to merge release fences");
             // synchronization is broken, the best we can do is hope fences
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index 10e999c..369712d 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -1228,19 +1228,15 @@ EGLImageKHR GLConsumer::EglImage::createImage(EGLDisplay dpy,
         EGL_NONE,
     };
     if (!crop.isValid()) {
-        // No crop rect to set, so leave the crop out of the attrib array. Make
-        // sure to propagate the protected content attrs if they are set.
-        attrs[2] = attrs[10];
-        attrs[3] = attrs[11];
-        attrs[4] = EGL_NONE;
+        // No crop rect to set, so terminate the attrib array before the crop.
+        attrs[2] = EGL_NONE;
+
     } else if (!isEglImageCroppable(crop)) {
         // The crop rect is not at the origin, so we can't set the crop on the
         // EGLImage because that's not allowed by the EGL_ANDROID_image_crop
         // extension.  In the future we can add a layered extension that
         // removes this restriction if there is hardware that can support it.
-        attrs[2] = attrs[10];
-        attrs[3] = attrs[11];
-        attrs[4] = EGL_NONE;
+        attrs[2] = EGL_NONE;
     }
     eglInitialize(dpy, 0, 0);
     EGLImageKHR image = eglCreateImageKHR(dpy, EGL_NO_CONTEXT,
diff --git a/libs/gui/IProducerListener.cpp b/libs/gui/IProducerListener.cpp
index da54ce1..81adc95 100644
--- a/libs/gui/IProducerListener.cpp
+++ b/libs/gui/IProducerListener.cpp
@@ -22,7 +22,6 @@ namespace android {
 
 enum {
     ON_BUFFER_RELEASED = IBinder::FIRST_CALL_TRANSACTION,
-    NEEDS_RELEASE_NOTIFY,
 };
 
 class BpProducerListener : public BpInterface<IProducerListener>
@@ -38,23 +37,6 @@ public:
         data.writeInterfaceToken(IProducerListener::getInterfaceDescriptor());
         remote()->transact(ON_BUFFER_RELEASED, data, &reply, IBinder::FLAG_ONEWAY);
     }
-
-    virtual bool needsReleaseNotify() {
-        bool result;
-        Parcel data, reply;
-        data.writeInterfaceToken(IProducerListener::getInterfaceDescriptor());
-        status_t err = remote()->transact(NEEDS_RELEASE_NOTIFY, data, &reply);
-        if (err != NO_ERROR) {
-            ALOGE("IProducerListener: binder call \'needsReleaseNotify\' failed");
-            return true;
-        }
-        err = reply.readBool(&result);
-        if (err != NO_ERROR) {
-            ALOGE("IProducerListener: malformed binder reply");
-            return true;
-        }
-        return result;
-    }
 };
 
 // Out-of-line virtual method definition to trigger vtable emission in this
@@ -70,16 +52,8 @@ status_t BnProducerListener::onTransact(uint32_t code, const Parcel& data,
             CHECK_INTERFACE(IProducerListener, data, reply);
             onBufferReleased();
             return NO_ERROR;
-        case NEEDS_RELEASE_NOTIFY:
-            CHECK_INTERFACE(IProducerListener, data, reply);
-            reply->writeBool(needsReleaseNotify());
-            return NO_ERROR;
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
 
-bool BnProducerListener::needsReleaseNotify() {
-    return true;
-}
-
 } // namespace android
diff --git a/libs/gui/SurfaceControl.cpp b/libs/gui/SurfaceControl.cpp
index d59b37c..6d732f9 100644
--- a/libs/gui/SurfaceControl.cpp
+++ b/libs/gui/SurfaceControl.cpp
@@ -132,6 +132,22 @@ status_t SurfaceControl::setBlurMaskAlphaThreshold(float alpha) {
     return mClient->setBlurMaskAlphaThreshold(mHandle, alpha);
 }
 status_t SurfaceControl::setPosition(float x, float y) {
+    const float ub = 20000.0;
+    const float lb = -20000.0;
+    if (CC_UNLIKELY(x > ub)) {
+        ALOGE("setPosition out of boundary: x = %f", x);
+        x = ub;
+    } else if (CC_UNLIKELY(x < lb)) {
+        ALOGE("setPosition out of boundary: x = %f", x);
+        x = lb;
+    }
+    if (CC_UNLIKELY(y > ub)) {
+        ALOGE("setPosition out of boundary: y = %f", y);
+        y = ub;
+    } else if (CC_UNLIKELY(x < lb)) {
+        ALOGE("setPosition out of boundary: y = %f", y);
+        y = lb;
+    }
     status_t err = validate();
     if (err < 0) return err;
     return mClient->setPosition(mHandle, x, y);
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index 2b16365..7e54a46 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -16,7 +16,7 @@ LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_CLANG := true
-LOCAL_CPPFLAGS := -std=c++1y -Weverything -Werror
+LOCAL_CPPFLAGS := -std=c++1y -Weverything
 # LOCAL_SANITIZE := integer
 
 # The static constructors and destructors in this library have not been noted to
@@ -56,6 +56,21 @@ LOCAL_SHARED_LIBRARIES := \
 	libutils \
 	liblog
 
+# --- MediaTek -------------------------------------------------------------
+LOCAL_CFLAGS += -DMTK_HARDWARE
+	LOCAL_CPPFLAGS += -Wno-extra-semi -Wno-zero-length-array -Wno-gnu-statement-expression
+	LOCAL_CPPFLAGS += -D__STDC_FORMAT_MACROS
+
+	LOCAL_SRC_FILES += \
+		mediatek/Fence.cpp \
+		mediatek/IDumpTunnel.cpp \
+		mediatek/RefBaseDump.cpp
+
+	LOCAL_SHARED_LIBRARIES += \
+		libbinder
+
+# --------------------------------------------------------------------------
+
 ifneq ($(BOARD_FRAMEBUFFER_FORCE_FORMAT),)
 LOCAL_CFLAGS += -DFRAMEBUFFER_FORCE_FORMAT=$(BOARD_FRAMEBUFFER_FORCE_FORMAT)
 endif
diff --git a/libs/ui/Fence.cpp b/libs/ui/Fence.cpp
index 5531b23..1ed8d96 100644
--- a/libs/ui/Fence.cpp
+++ b/libs/ui/Fence.cpp
@@ -67,12 +67,15 @@ status_t Fence::waitForever(const char* logname) {
     if (err < 0 && errno == ETIME) {
         ALOGE("%s: fence %d didn't signal in %u ms", logname, mFenceFd,
                 warningTimeout);
+
+        dump(mFenceFd);
+
         err = sync_wait(mFenceFd, TIMEOUT_NEVER);
     }
     return err < 0 ? -errno : status_t(NO_ERROR);
 }
 
-sp<Fence> Fence::merge(const char* name, const sp<Fence>& f1,
+sp<Fence> Fence::merge(const String8& name, const sp<Fence>& f1,
         const sp<Fence>& f2) {
     ATRACE_CALL();
     int result;
@@ -80,29 +83,24 @@ sp<Fence> Fence::merge(const char* name, const sp<Fence>& f1,
     // valid fence (e.g. NO_FENCE) we merge the one valid fence with itself so
     // that a new fence with the given name is created.
     if (f1->isValid() && f2->isValid()) {
-        result = sync_merge(name, f1->mFenceFd, f2->mFenceFd);
+        result = sync_merge(name.string(), f1->mFenceFd, f2->mFenceFd);
     } else if (f1->isValid()) {
-        result = sync_merge(name, f1->mFenceFd, f1->mFenceFd);
+        result = sync_merge(name.string(), f1->mFenceFd, f1->mFenceFd);
     } else if (f2->isValid()) {
-        result = sync_merge(name, f2->mFenceFd, f2->mFenceFd);
+        result = sync_merge(name.string(), f2->mFenceFd, f2->mFenceFd);
     } else {
         return NO_FENCE;
     }
     if (result == -1) {
         status_t err = -errno;
         ALOGE("merge: sync_merge(\"%s\", %d, %d) returned an error: %s (%d)",
-                name, f1->mFenceFd, f2->mFenceFd,
+                name.string(), f1->mFenceFd, f2->mFenceFd,
                 strerror(-err), err);
         return NO_FENCE;
     }
     return sp<Fence>(new Fence(result));
 }
 
-sp<Fence> Fence::merge(const String8& name, const sp<Fence>& f1,
-        const sp<Fence>& f2) {
-    return merge(name.string(), f1, f2);
-}
-
 int Fence::dup() const {
     return ::dup(mFenceFd);
 }
diff --git a/libs/ui/GraphicBuffer.cpp b/libs/ui/GraphicBuffer.cpp
index df31d5f..b316c53 100644
--- a/libs/ui/GraphicBuffer.cpp
+++ b/libs/ui/GraphicBuffer.cpp
@@ -34,6 +34,33 @@ namespace android {
 // Buffer and implementation of ANativeWindowBuffer
 // ===========================================================================
 
+class GraphicBufferStubDecker {
+ public:
+  ~GraphicBufferStubDecker();
+  GraphicBufferStubDecker(uint32_t inWidth, uint32_t inHeight,
+        PixelFormat inFormat, uint32_t inUsage);
+  sp<android::GraphicBuffer> mBuffer;
+};
+
+GraphicBufferStubDecker::GraphicBufferStubDecker(uint32_t inWidth, uint32_t inHeight,
+        PixelFormat inFormat, uint32_t inUsage)
+  : mBuffer(new android::GraphicBuffer(inWidth, inHeight, inFormat, inUsage)) {
+} // constructors take base initializers
+
+GraphicBufferStubDecker::~GraphicBufferStubDecker() {} // деструктор
+
+// экспорт
+extern "C" {
+
+void _ZN7android13GraphicBufferC1Ejjij(uint32_t inWidth, uint32_t inHeight,
+        PixelFormat inFormat, uint32_t inUsage); // прототип
+
+void _ZN7android13GraphicBufferC1Ejjij(uint32_t inWidth, uint32_t inHeight,
+        PixelFormat inFormat, uint32_t inUsage) {
+	GraphicBufferStubDecker::GraphicBufferStubDecker(inWidth, inHeight, inFormat, inUsage);
+}
+}
+
 static uint64_t getUniqueId() {
     static volatile int32_t nextId = 0;
     uint64_t id = static_cast<uint64_t>(getpid()) << 32;
diff --git a/libs/ui/mediatek/Fence.cpp b/libs/ui/mediatek/Fence.cpp
new file mode 100644
index 0000000..1b832de
--- /dev/null
+++ b/libs/ui/mediatek/Fence.cpp
@@ -0,0 +1,58 @@
+#define LOG_TAG "Fence"
+
+#include <inttypes.h>
+#include <sync/sync.h>
+#include <ui/Fence.h>
+#include <unistd.h>
+
+#include <cutils/log.h>
+
+// ---------------------------------------------------------------------------
+
+static const char* findKeyWord(const char* msg) {
+    android::String8 obj_name(msg);
+    obj_name.toLower();
+    const char* OBJ_NAME = obj_name.string();
+
+    // NOTE: keep these keywords in sync with MOF
+    android::String8 keyword("timeline_");
+    if (strstr(OBJ_NAME, "surfaceflinger")) {
+        keyword.append("SurfaceFlinger");
+    } else if (strstr(OBJ_NAME, "ovl_timeline")) {
+        keyword.append("ovl_timeline");
+    } else if (strstr(OBJ_NAME, "mali")) {
+        keyword.append("mali");
+    }
+
+    return keyword.string();
+}
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+
+void Fence::dump(int fd) {
+    if (-1 == fd) return;
+
+    struct sync_fence_info_data *info = sync_fence_info(fd);
+    if (info) {
+        struct sync_pt_info *pt_info = NULL;
+        // status: active(0) signaled(1) error(<0)
+        ALOGI("fence(%s) status(%d)", info->name, info->status);
+
+        // iterate active/error sync points
+        while ((pt_info = sync_pt_info(info, pt_info))) {
+            if (NULL != pt_info && pt_info->status <= 0) {
+                uint64_t ts_sec = pt_info->timestamp_ns / 1000000000LL;
+                uint64_t ts_usec = (pt_info->timestamp_ns % 1000000000LL) / 1000LL;
+
+                ALOGI("sync point: timeline(%s) drv(%s) status(%d) sync_drv(%u) timestamp(%" PRIu64 ".%06" PRIu64 ")",
+                    pt_info->obj_name, pt_info->driver_name, pt_info->status,
+                    *reinterpret_cast<uint32_t*>(pt_info->driver_data), ts_sec, ts_usec);
+            }
+        }
+        sync_fence_info_free(info);
+    }
+}
+
+} // namespace android
diff --git a/libs/ui/mediatek/IDumpTunnel.cpp b/libs/ui/mediatek/IDumpTunnel.cpp
new file mode 100644
index 0000000..1f1d836
--- /dev/null
+++ b/libs/ui/mediatek/IDumpTunnel.cpp
@@ -0,0 +1,116 @@
+#define LOG_TAG "DumpTunnel"
+
+#define MTK_LOG_ENABLE 1
+#include <dlfcn.h>
+#include <utils/String8.h>
+#include <binder/Parcel.h>
+#include <cutils/log.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android {
+
+// client : proxy GuiEx class
+class BpDumpTunnel : public BpInterface<IDumpTunnel> {
+public:
+    BpDumpTunnel(const sp<IBinder>& impl)
+        :   BpInterface<IDumpTunnel>(impl) {
+    }
+
+    virtual ~BpDumpTunnel();
+
+    virtual status_t kickDump(String8& result, const char* prefix) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
+        data.writeString8(result);
+        data.writeCString(prefix);
+        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
+        if (err != NO_ERROR) {
+            ALOGE("kickDump could not contact remote\n");
+            return err;
+        }
+        result = reply.readString8();
+        err = reply.readInt32();
+        return err;
+    }
+};
+
+// Out-of-line virtual method definition to trigger vtable emission in this
+// translation unit (see clang warning -Wweak-vtables)
+BpDumpTunnel::~BpDumpTunnel() {}
+
+IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
+
+status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
+    switch (code) {
+        case DUMPTUNNEL_DUMP: {
+            CHECK_INTERFACE(IDumpTunnel, data, reply);
+            String8 result;
+            const char* prefix = NULL;
+            result = data.readString8();
+            prefix = data.readCString();
+
+            status_t ret = kickDump(result, prefix);
+            reply->writeString8(result);
+            reply->writeInt32(ret);
+            return NO_ERROR;
+        }
+    }
+    return BBinder::onTransact(code, data, reply, flags);
+}
+
+// ----------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
+
+DumpTunnelHelper::DumpTunnelHelper() :
+    mSoHandle(NULL),
+    mRegDumpPtr(NULL),
+    mUnregDumpPtr(NULL)
+{
+    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
+    typedef bool (*UnregDumpPrototype)(const String8&);
+
+    // dlopen must set RTLD_LAZY flag because of performance issue
+    mSoHandle = dlopen("libgui_ext.so", RTLD_LAZY);
+    if (mSoHandle) {
+        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
+        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
+        if (NULL == mRegDumpPtr) {
+            ALOGE("finding regDump() failed");
+        }
+        if (NULL == mUnregDumpPtr) {
+            ALOGE("finding unregDump() failed");
+        }
+    } else {
+        ALOGE("open libgui_ext failed");
+    }
+}
+
+DumpTunnelHelper::~DumpTunnelHelper() {
+    if(mSoHandle != NULL)
+        dlclose(mSoHandle);
+}
+
+bool DumpTunnelHelper::regDump(const sp<IDumpTunnel>& tunnel, const String8& key) {
+    bool result = false;
+    if (NULL == mRegDumpPtr) {
+        ALOGE("finding regDump() failed");
+        return result;
+    }
+    result = mRegDumpPtr(tunnel, key);
+
+    return result;
+}
+
+bool DumpTunnelHelper::unregDump(const String8& key) {
+    bool result = false;
+    if (NULL == mUnregDumpPtr) {
+        ALOGE("finding unregDump() failed");
+        return result;
+    }
+    result = mUnregDumpPtr(key);
+
+    return result;
+}
+
+};
diff --git a/libs/ui/mediatek/RefBaseDump.cpp b/libs/ui/mediatek/RefBaseDump.cpp
new file mode 100644
index 0000000..8dcd5ab
--- /dev/null
+++ b/libs/ui/mediatek/RefBaseDump.cpp
@@ -0,0 +1,70 @@
+#define LOG_TAG "RefBaseDump"
+
+#if 0
+#define RBD_LOGV(x, ...) ALOGV(x, ##__VA_ARGS__)
+#define RBD_LOGD(x, ...) ALOGD(x, ##__VA_ARGS__)
+#define RBD_LOGI(x, ...) ALOGI(x, ##__VA_ARGS__)
+#define RBD_LOGW(x, ...) ALOGW(x, ##__VA_ARGS__)
+#define RBD_LOGE(x, ...) ALOGE(x, ##__VA_ARGS__)
+#else
+//#define RBD_LOGV(x, ...)
+//#define RBD_LOGD(x, ...)
+#define RBD_LOGI(x, ...)
+//#define RBD_LOGW(x, ...)
+//#define RBD_LOGE(x, ...)
+#endif
+
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <ui/mediatek/RefBaseDump.h>
+
+namespace android {
+
+
+IMPLEMENT_META_GUIEXTMONITOR(RefBaseMonitor, RefBase*, "RB");
+
+RefBaseMonitor::RefBaseMonitor() {
+    char value[PROPERTY_VALUE_MAX];
+    RBD_LOGI("RefBaseMonitor ctor - %p", this);
+    getProcessName();
+    property_get("debug.rb.dump", value, "Mary had a little lamb");
+    mIsTracking = (-1 != mProcessName.find(value));
+}
+
+
+status_t RefBaseMonitor::monitor(RefBase* pRb) {
+    if (mIsTracking) {
+        pRb->trackMe(true, false);
+    }
+    return GuiExtMonitor<RefBaseMonitor, RefBase*>::monitor(pRb);
+}
+
+
+status_t RefBaseMonitor::dump(String8& result, const char* /*prefix*/) {
+    size_t listSz;
+    RefBase* pRb;
+    Mutex::Autolock _l(mLock);
+    RBD_LOGI("RefBaseMonitor Dump - %p", this);
+    listSz = mItemList.size();
+    result.appendFormat("\t  [%8p]    RefCnt   %s", this, mProcessName.string());
+    result.append(mIsTracking ? " <- tracking\n" : "\n");
+    result.append("\t  -----------------------\n");
+
+    for (size_t i = 0; i < listSz; i++) {
+        pRb = mItemList.keyAt(i);
+        if (mIsTracking) {
+            pRb->printRefs();
+        }
+        result.appendFormat("\t   %2zu) %8p %4d\n", i, pRb, pRb->getStrongCount());
+    }
+    result.append("\t*****************************************************\n");
+    return NO_ERROR;
+}
+
+
+String8 RefBaseMonitor::getKeyName() const {
+    return String8::format("RB-%p", this);
+}
+
+
+}; // namespace android
diff --git a/opengl/include/EGL/eglext.h b/opengl/include/EGL/eglext.h
index 2e18698..e2c6150 100644
--- a/opengl/include/EGL/eglext.h
+++ b/opengl/include/EGL/eglext.h
@@ -621,6 +621,9 @@ typedef EGLAPI EGLClientBuffer (EGLAPIENTRYP PFNEGLCREATENATIVECLIENTBUFFERANDRO
 #define EGL_MUTABLE_RENDER_BUFFER_BIT_KHR 0x1000
 #endif
 
+void* egl_GVR_FrontBuffer(const EGLSurface surface);
+void* EGL_SEC_getClientBufferForFrontBuffer(EGLSurface surface);
+
 #ifndef EGL_ANDROID_get_frame_timestamps
 #define EGL_ANDROID_get_frame_timestamps 1
 #define EGL_TIMESTAMPS_ANDROID 0x314D
@@ -638,6 +641,9 @@ typedef EGLAPI EGLBoolean (EGLAPIENTRYP PFNEGLGETFRAMETIMESTAMPSANDROID) (EGLDis
 typedef EGLAPI EGLBoolean (EGLAPIENTRYP PFNEGLQUERYTIMESTAMPSUPPORTEDANDROID) (EGLDisplay dpy, EGLSurface surface, EGLint timestamp);
 #endif
 #endif
+void* egl_GVR_FrontBuffer(const EGLSurface surface);
+void* EGL_SEC_getClientBufferForFrontBuffer(EGLSurface surface);
+#define EGL_IS_INVALID_MTK    0x43210001
 
 #ifdef __cplusplus
 }
diff --git a/opengl/libs/EGL/Loader.cpp b/opengl/libs/EGL/Loader.cpp
index 4234db8..a1a1a80 100644
--- a/opengl/libs/EGL/Loader.cpp
+++ b/opengl/libs/EGL/Loader.cpp
@@ -125,11 +125,6 @@ static char const * getProcessCmdline() {
     return NULL;
 }
 
-static void* do_dlopen(const char* path, int mode) {
-    ATRACE_CALL();
-    return dlopen(path, mode);
-}
-
 // ----------------------------------------------------------------------------
 
 Loader::driver_t::driver_t(void* gles)
@@ -170,30 +165,14 @@ status_t Loader::driver_t::set(void* hnd, int32_t api)
 // ----------------------------------------------------------------------------
 
 Loader::Loader()
-    : getProcAddress(NULL),
-      mLibGui(nullptr),
-      mGetDriverNamespace(nullptr)
-{
-    // FIXME: See note in GraphicsEnv.h about android_getDriverNamespace().
-    // libgui should already be loaded in any process that uses libEGL, but
-    // if for some reason it isn't, then we're not going to get a driver
-    // namespace anyway, so don't force it to be loaded.
-    mLibGui = dlopen("libgui.so", RTLD_NOLOAD | RTLD_LOCAL | RTLD_LAZY);
-    if (!mLibGui) {
-        ALOGD("failed to load libgui: %s", dlerror());
-        return;
-    }
-    mGetDriverNamespace = reinterpret_cast<decltype(mGetDriverNamespace)>(
-            dlsym(mLibGui, "android_getDriverNamespace"));
+    : getProcAddress(NULL) {
 }
 
 Loader::~Loader() {
-    if (mLibGui)
-        dlclose(mLibGui);
 }
 
 static void* load_wrapper(const char* path) {
-    void* so = do_dlopen(path, RTLD_NOW | RTLD_LOCAL);
+    void* so = dlopen(path, RTLD_NOW | RTLD_LOCAL);
     ALOGE_IF(!so, "dlopen(\"%s\") failed: %s", path, dlerror());
     return so;
 }
@@ -347,8 +326,10 @@ void Loader::init_api(void* dso,
         api++;
     }
 }
+void *Loader::load_driver(const char* kind,
+        egl_connection_t* cnx, uint32_t mask)
+{
 
-static void* load_system_driver(const char* kind) {
     ATRACE_CALL();
     class MatchFile {
     public:
@@ -465,7 +446,7 @@ static void* load_system_driver(const char* kind) {
     }
     const char* const driver_absolute_path = absolutePath.string();
 
-    void* dso = do_dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL);
+    void* dso = dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL);
     if (dso == 0) {
         const char* err = dlerror();
         ALOGE("load_driver(%s): %s", driver_absolute_path, err?err:"unknown");
@@ -474,63 +455,11 @@ static void* load_system_driver(const char* kind) {
 
     ALOGD("loaded %s", driver_absolute_path);
 
-    return dso;
-}
-
-static void* do_android_dlopen_ext(const char* path, int mode, const android_dlextinfo* info) {
-    ATRACE_CALL();
-    return android_dlopen_ext(path, mode, info);
-}
-
-static const std::array<const char*, 2> HAL_SUBNAME_KEY_PROPERTIES = {{
-    "ro.hardware.egl",
-    "ro.board.platform",
-}};
-
-static void* load_updated_driver(const char* kind, android_namespace_t* ns) {
-    ATRACE_CALL();
-    const android_dlextinfo dlextinfo = {
-        .flags = ANDROID_DLEXT_USE_NAMESPACE,
-        .library_namespace = ns,
-    };
-    void* so = nullptr;
-    char prop[PROPERTY_VALUE_MAX + 1];
-    for (auto key : HAL_SUBNAME_KEY_PROPERTIES) {
-        if (property_get(key, prop, nullptr) > 0) {
-            String8 name;
-            name.appendFormat("lib%s_%s.so", kind, prop);
-            so = do_android_dlopen_ext(name.string(), RTLD_LOCAL | RTLD_NOW,
-                    &dlextinfo);
-            if (so)
-                return so;
-        }
-    }
-    return nullptr;
-}
-
-void *Loader::load_driver(const char* kind,
-        egl_connection_t* cnx, uint32_t mask)
-{
-    ATRACE_CALL();
-
-    void* dso = nullptr;
-    if (mGetDriverNamespace) {
-        android_namespace_t* ns = mGetDriverNamespace();
-        if (ns) {
-            dso = load_updated_driver(kind, ns);
-        }
-    }
-    if (!dso) {
-        dso = load_system_driver(kind);
-        if (!dso)
-            return NULL;
-    }
-
     if (mask & EGL) {
         getProcAddress = (getProcAddressType)dlsym(dso, "eglGetProcAddress");
 
         ALOGE_IF(!getProcAddress,
-                "can't find eglGetProcAddress() in EGL driver library");
+                "can't find eglGetProcAddress() in %s", driver_absolute_path);
 
         egl_t* egl = &cnx->egl;
         __eglMustCastToProperFunctionPointerType* curr =
diff --git a/opengl/libs/EGL/Loader.h b/opengl/libs/EGL/Loader.h
index 04a8e41..3bfd894 100644
--- a/opengl/libs/EGL/Loader.h
+++ b/opengl/libs/EGL/Loader.h
@@ -55,10 +55,6 @@ class Loader : public Singleton<Loader>
     };
     
     getProcAddressType getProcAddress;
-
-    void* mLibGui;
-    decltype(android_getDriverNamespace)* mGetDriverNamespace;
-
 public:
     ~Loader();
     
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 0cd8b02..9590c4d 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -219,6 +219,11 @@ static const extention_map_t sExtensionMap[] = {
     { "eglCreateStreamFromFileDescriptorKHR",
             (__eglMustCastToProperFunctionPointerType)&eglCreateStreamFromFileDescriptorKHR },
 
+    { "egl_GVR_FrontBuffer",
+            (__eglMustCastToProperFunctionPointerType)&egl_GVR_FrontBuffer },
+    { "EGL_SEC_getClientBufferForFrontBuffer",
+            (__eglMustCastToProperFunctionPointerType)&EGL_SEC_getClientBufferForFrontBuffer },
+
     // EGL_ANDROID_get_frame_timestamps
     { "eglGetFrameTimestampsANDROID",
             (__eglMustCastToProperFunctionPointerType)&eglGetFrameTimestampsANDROID },
@@ -659,6 +664,16 @@ EGLBoolean eglQuerySurface( EGLDisplay dpy, EGLSurface surface,
         return setError(EGL_BAD_SURFACE, EGL_FALSE);
 
     egl_surface_t const * const s = get_surface(surface);
+
+    if (attribute == EGL_IS_INVALID_MTK)
+    {
+        int tmp_w;
+        EGLNativeWindowType win = (EGLNativeWindowType)s->win.get();
+
+        *value = s->win->query(win, NATIVE_WINDOW_HEIGHT, &tmp_w) != 0 ? 1 : 0;
+        return EGL_TRUE;
+    }
+
     return s->cnx->egl.eglQuerySurface(
             dp->disp.dpy, s->surface, attribute, value);
 }
@@ -834,6 +849,19 @@ EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
         // this will ALOGE the error
         egl_connection_t* const cnx = &gEGLImpl;
         result = setError(cnx->egl.eglGetError(), EGL_FALSE);
+
+        if (NULL != cur_c)
+        {
+            SurfaceRef _cur_r(get_surface(cur_c->read));
+            SurfaceRef _cur_d(get_surface(cur_c->draw));
+
+            cur_c->read = EGL_NO_SURFACE;
+            cur_c->draw = EGL_NO_SURFACE;
+
+            _cur_r.release();
+            _cur_d.release();
+        }
+
     }
     return result;
 }
@@ -1867,6 +1895,13 @@ EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
                     if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
                         usage |= GRALLOC_USAGE_HW_TEXTURE;
                     }
+
+                    // The buffer must be used for either a texture or a
+                    // renderbuffer.
+                    if ((value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) &&
+                        (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID)) {
+                        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
+                    }
                     break;
                 default:
                     return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
@@ -2036,6 +2071,41 @@ EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
     return EGL_FALSE;
 }
 
+void* egl_GVR_FrontBuffer(const EGLSurface surface)
+{
+    clearError();
+    ALOGW("[MTKME2] [egl_GVR_FrontBuffer] [+]: surface(%p)\n", surface);
+
+    int fbr_egl_enabled = 1;
+    char prop_value[128];
+
+    if (property_get("mtk.egl.fbr.enable", prop_value, "1") > 0) {
+        fbr_egl_enabled = atoi(prop_value);
+    }
+
+    if (!fbr_egl_enabled) {
+        ALOGW("[MTKME2] [egl_GVR_FrontBuffer] [-]: return NULL! FBR is not enabled, fbr_egl_enabled(%d)\n", fbr_egl_enabled);
+        return NULL;
+    }
+
+    egl_surface_t const * const s = get_surface(surface);
+    if (s->cnx->egl.eglGvrFrontBuffer) {
+        if(s->cnx->egl.eglGvrFrontBuffer(s->surface)) {
+            ALOGW("[MTKME2] [egl_GVR_FrontBuffer] [-]: return surface(%p)\n", surface);
+            return surface;
+        }
+    }
+
+    ALOGW("[MTKME2] [egl_GVR_FrontBuffer] [-]: return NULL!\n");
+    return NULL;
+}
+
+void* EGL_SEC_getClientBufferForFrontBuffer(EGLSurface surface)
+{
+    ALOGW("[MTKME2] [EGL_SEC_getClientBufferForFrontBuffer]: surface(%p)\n", surface);
+    return NULL;
+}
+
 EGLBoolean eglGetFrameTimestampsANDROID(EGLDisplay dpy, EGLSurface surface,
         EGLint framesAgo, EGLint numTimestamps, const EGLint *timestamps,
         EGLnsecsANDROID *values)
diff --git a/opengl/libs/EGL/egl_entries.in b/opengl/libs/EGL/egl_entries.in
index 2b56718..c304973 100644
--- a/opengl/libs/EGL/egl_entries.in
+++ b/opengl/libs/EGL/egl_entries.in
@@ -96,3 +96,6 @@ EGL_ENTRY(EGLBoolean, eglAwakenProcessIMG, void)
 
 EGL_ENTRY(EGLBoolean, eglSwapBuffersWithDamageKHR, EGLDisplay, EGLSurface, EGLint *, EGLint)
 EGL_ENTRY(EGLBoolean, eglSetDamageRegionKHR, EGLDisplay, EGLSurface, EGLint *, EGLint)
+
+/* MTK AOSP ENHANCEMENT */
+EGL_ENTRY(EGLBoolean, eglGvrFrontBuffer, const EGLSurface)
\ No newline at end of file
diff --git a/vulkan/libvulkan/driver.cpp b/vulkan/libvulkan/driver.cpp
index ba99d0c..1fba9c0 100644
--- a/vulkan/libvulkan/driver.cpp
+++ b/vulkan/libvulkan/driver.cpp
@@ -129,81 +129,17 @@ class CreateInfoWrapper {
 
 Hal Hal::hal_;
 
-void* LoadLibrary(const android_dlextinfo& dlextinfo,
-                  const char* subname,
-                  int subname_len) {
-    const char kLibFormat[] = "vulkan.%*s.so";
-    char* name = static_cast<char*>(
-        alloca(sizeof(kLibFormat) + static_cast<size_t>(subname_len)));
-    sprintf(name, kLibFormat, subname_len, subname);
-    return android_dlopen_ext(name, RTLD_LOCAL | RTLD_NOW, &dlextinfo);
-}
-
-const std::array<const char*, 2> HAL_SUBNAME_KEY_PROPERTIES = {{
-    "ro.hardware." HWVULKAN_HARDWARE_MODULE_ID,
-    "ro.board.platform",
-}};
-
-int LoadUpdatedDriver(const hw_module_t** module) {
-    const android_dlextinfo dlextinfo = {
-        .flags = ANDROID_DLEXT_USE_NAMESPACE,
-        .library_namespace = android::GraphicsEnv::getInstance().getDriverNamespace(),
-    };
-    if (!dlextinfo.library_namespace)
-        return -ENOENT;
-
-    void* so = nullptr;
-    char prop[PROPERTY_VALUE_MAX];
-    for (auto key : HAL_SUBNAME_KEY_PROPERTIES) {
-        int prop_len = property_get(key, prop, nullptr);
-        if (prop_len > 0) {
-            so = LoadLibrary(dlextinfo, prop, prop_len);
-            if (so)
-                break;
-        }
-    }
-    if (!so)
-        return -ENOENT;
-
-    hw_module_t* hmi = static_cast<hw_module_t*>(dlsym(so, HAL_MODULE_INFO_SYM_AS_STR));
-    if (!hmi) {
-        ALOGE("couldn't find symbol '%s' in HAL library: %s", HAL_MODULE_INFO_SYM_AS_STR, dlerror());
-        dlclose(so);
-        return -EINVAL;
-    }
-    if (strcmp(hmi->id, HWVULKAN_HARDWARE_MODULE_ID) != 0) {
-        ALOGE("HAL id '%s' != '%s'", hmi->id, HWVULKAN_HARDWARE_MODULE_ID);
-        dlclose(so);
-        return -EINVAL;
-    }
-    hmi->dso = so;
-    *module = hmi;
-    ALOGD("loaded updated driver");
-    return 0;
-}
-
 bool Hal::Open() {
     ALOG_ASSERT(!hal_.dev_, "OpenHAL called more than once");
 
     // Use a stub device unless we successfully open a real HAL device.
     hal_.dev_ = &stubhal::kDevice;
 
-    int result;
-    const hwvulkan_module_t* module = nullptr;
-
-    // Use stub HAL if vulkan is disabled
-    bool disableVulkan = property_get_bool("persist.graphics.vulkan.disable", false);
-    if (disableVulkan == true) {
-        ALOGI("no Vulkan HAL present, using stub HAL");
-        return true;
-    }
-
-    result = LoadUpdatedDriver(reinterpret_cast<const hw_module_t**>(&module));
-    if (result == -ENOENT) {
-        result = hw_get_module(HWVULKAN_HARDWARE_MODULE_ID, reinterpret_cast<const hw_module_t**>(&module));
-    }
+    const hwvulkan_module_t* module;
+    int result =
+        hw_get_module("vulkan", reinterpret_cast<const hw_module_t**>(&module));
     if (result != 0) {
-        ALOGV("unable to load Vulkan HAL, using stub HAL (result=%d)", result);
+        ALOGI("no Vulkan HAL present, using stub HAL");
         return true;
     }
 
-- 
2.7.4

